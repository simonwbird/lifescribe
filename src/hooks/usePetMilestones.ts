import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { supabase } from '@/integrations/supabase/client'
import { PetMilestone, UpcomingMilestone } from '@/lib/petMilestoneTypes'
import { toast } from 'sonner'

// Map database row to PetMilestone type
function mapMilestoneRow(row: any): PetMilestone {
  return {
    id: row.id,
    petId: row.pet_id,
    familyId: row.family_id,
    title: row.title,
    date: row.date,
    notes: row.notes,
    autoGenerated: row.auto_generated,
    milestoneType: row.milestone_type,
    createdBy: row.created_by,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  }
}

// Fetch milestones for a specific pet
export function usePetMilestones(petId: string | null) {
  return useQuery({
    queryKey: ['pet-milestones', petId],
    queryFn: async (): Promise<PetMilestone[]> => {
      if (!petId) return []

      const { data, error } = await supabase
        .from('pet_milestones')
        .select('*')
        .eq('pet_id', petId)
        .order('date', { ascending: false })

      if (error) throw error
      return (data || []).map(mapMilestoneRow)
    },
    enabled: !!petId,
  })
}

// Fetch upcoming milestones across all pets in a family (next N days)
export function useUpcomingMilestones(familyId: string | null, days: number = 30) {
  return useQuery({
    queryKey: ['upcoming-milestones', familyId, days],
    queryFn: async (): Promise<UpcomingMilestone[]> => {
      if (!familyId) return []

      const today = new Date()
      const futureDate = new Date()
      futureDate.setDate(today.getDate() + days)

      const { data: milestones, error: milestonesError } = await supabase
        .from('pet_milestones')
        .select(`
          *,
          pets:pet_id (
            name,
            cover_url
          )
        `)
        .eq('family_id', familyId)
        .gte('date', today.toISOString().split('T')[0])
        .lte('date', futureDate.toISOString().split('T')[0])
        .order('date', { ascending: true })

      if (milestonesError) throw milestonesError

      return (milestones || []).map((row: any) => {
        const milestone = mapMilestoneRow(row)
        const milestoneDate = new Date(milestone.date)
        const daysUntil = Math.ceil((milestoneDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24))

        return {
          ...milestone,
          petName: row.pets?.name || 'Unknown Pet',
          petAvatar: row.pets?.cover_url,
          daysUntil,
        }
      })
    },
    enabled: !!familyId,
  })
}

// Add a new milestone
export function useAddMilestone() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (milestone: Omit<PetMilestone, 'id' | 'createdAt' | 'updatedAt'>) => {
      const { data, error } = await supabase
        .from('pet_milestones')
        .insert({
          pet_id: milestone.petId,
          family_id: milestone.familyId,
          title: milestone.title,
          date: milestone.date,
          notes: milestone.notes,
          auto_generated: milestone.autoGenerated,
          milestone_type: milestone.milestoneType,
          created_by: milestone.createdBy,
        })
        .select()
        .single()

      if (error) throw error
      return mapMilestoneRow(data)
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['pet-milestones', data.petId] })
      queryClient.invalidateQueries({ queryKey: ['upcoming-milestones'] })
      toast.success('Milestone added successfully')
    },
    onError: (error) => {
      console.error('Error adding milestone:', error)
      toast.error('Failed to add milestone')
    },
  })
}

// Update a milestone
export function useUpdateMilestone() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ id, updates }: { id: string; updates: Partial<PetMilestone> }) => {
      const { data, error } = await supabase
        .from('pet_milestones')
        .update({
          title: updates.title,
          date: updates.date,
          notes: updates.notes,
          milestone_type: updates.milestoneType,
        })
        .eq('id', id)
        .select()
        .single()

      if (error) throw error
      return mapMilestoneRow(data)
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['pet-milestones', data.petId] })
      queryClient.invalidateQueries({ queryKey: ['upcoming-milestones'] })
      toast.success('Milestone updated successfully')
    },
    onError: (error) => {
      console.error('Error updating milestone:', error)
      toast.error('Failed to update milestone')
    },
  })
}

// Delete a milestone
export function useDeleteMilestone() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from('pet_milestones')
        .delete()
        .eq('id', id)

      if (error) throw error
      return id
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pet-milestones'] })
      queryClient.invalidateQueries({ queryKey: ['upcoming-milestones'] })
      toast.success('Milestone deleted successfully')
    },
    onError: (error) => {
      console.error('Error deleting milestone:', error)
      toast.error('Failed to delete milestone')
    },
  })
}
