import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
    );

    const { taskId, taskBrief, bugReport } = await req.json();

    console.log('Processing Loveable submission for task:', taskId);

    // In a real implementation, you would integrate with Loveable's API here
    // For now, we'll simulate the process and create a mock response
    
    // Update the AI task with a simulated Loveable task ID
    const loveableTaskId = `loveable_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    const { error: updateError } = await supabaseClient
      .from('ai_tasks')
      .update({
        loveable_task_id: loveableTaskId,
        status: 'submitted',
        updated_at: new Date().toISOString()
      })
      .eq('id', taskId);

    if (updateError) {
      throw updateError;
    }

    // Start background task to poll for completion (simulated)
    // Note: EdgeRuntime.waitUntil is not available in current Deno environment
    simulateLoveableProcessing(supabaseClient, taskId, loveableTaskId, bugReport).catch(console.error);

    return new Response(JSON.stringify({
      success: true,
      loveableTaskId,
      message: 'Task successfully submitted to Loveable'
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('Error in submit-to-loveable function:', error);
    
    return new Response(JSON.stringify({
      error: error instanceof Error ? error.message : 'Unknown error',
      success: false
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

async function simulateLoveableProcessing(supabaseClient: any, taskId: string, loveableTaskId: string, bugReport: any) {
  try {
    console.log('Starting simulated Loveable processing for task:', taskId);
    
    // Simulate processing time (30-60 seconds)
    const processingTime = Math.random() * 30000 + 30000; // 30-60 seconds
    await new Promise(resolve => setTimeout(resolve, processingTime));

    // Simulate different types of responses
    const responseType = Math.random() > 0.5 ? 'pr' : 'patch';
    
    let loveableResponse;
    let resultData: any = {};

    if (responseType === 'pr') {
      // Simulate GitHub PR creation
      const mockPrUrl = `https://github.com/user/repo/pull/${Math.floor(Math.random() * 1000) + 1}`;
      loveableResponse = {
        type: 'github_pr',
        pr_url: mockPrUrl,
        title: `Fix: ${bugReport.title}`,
        description: 'Automated fix generated by Loveable AI',
        files_changed: [
          'src/components/ui/button.tsx',
          'src/pages/dashboard/index.tsx'
        ],
        tests_added: true
      };
      resultData.github_pr_url = mockPrUrl;
      resultData.result_type = 'pr';
    } else {
      // Simulate inline patch
      const mockPatch = `--- a/src/components/Component.tsx
+++ b/src/components/Component.tsx
@@ -10,7 +10,7 @@
   const handleClick = () => {
-    // Bug: Missing null check
-    data.forEach(item => {
+    // Fix: Added null check to prevent errors
+    data?.forEach(item => {
       processItem(item);
     });
   };`;
      
      loveableResponse = {
        type: 'inline_patch',
        patch: mockPatch,
        description: 'Added null safety check to prevent runtime errors',
        files_modified: ['src/components/Component.tsx'],
        explanation: 'The issue was caused by missing null checking on the data array. This patch adds optional chaining to safely iterate over the array.'
      };
      resultData.inline_patch = mockPatch;
      resultData.result_type = 'patch';
    }

    // Update AI task with completion
    const { error: updateError } = await supabaseClient
      .from('ai_tasks')
      .update({
        status: 'completed',
        loveable_response: loveableResponse,
        ...resultData,
        completed_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .eq('id', taskId);

    if (updateError) {
      console.error('Error updating AI task:', updateError);
      throw updateError;
    }

    // Add comment to the bug report
    const commentText = responseType === 'pr' 
      ? `ðŸ¤– **Loveable AI Fix Complete**\n\nA fix has been generated and submitted as a GitHub PR: ${resultData.github_pr_url}\n\n**Files Changed:**\n${(loveableResponse.files_changed || []).map((f: string) => `- ${f}`).join('\n')}\n\nPlease review and merge the PR to complete the fix.`
      : `ðŸ¤– **Loveable AI Fix Complete**\n\nAn inline patch has been generated to fix this issue:\n\n**Explanation:** ${loveableResponse.explanation}\n\n**Files Modified:**\n${(loveableResponse.files_modified || []).map((f: string) => `- ${f}`).join('\n')}\n\n\`\`\`diff\n${loveableResponse.patch}\n\`\`\`\n\nApply this patch to resolve the issue.`;

    // Get the user who created the AI task to use as commenter
    const { data: aiTaskData } = await supabaseClient
      .from('ai_tasks')
      .select('created_by')
      .eq('id', taskId)
      .single();

    if (aiTaskData) {
      const { error: commentError } = await supabaseClient
        .from('comments')
        .insert({
          content: commentText,
          profile_id: aiTaskData.created_by,
          family_id: bugReport.family_id,
          story_id: null, // This is for a bug report, not a story
          // Note: We'd need to add bug_report_id to comments table to properly link this
        });

      if (commentError) {
        console.error('Error creating comment:', commentError);
        // Don't throw here as the main task was successful
      }
    }

    // Update bug status to QA Ready
    const { error: bugUpdateError } = await supabaseClient
      .from('bug_reports')
      .update({ 
        status: 'QA Ready',
        updated_at: new Date().toISOString()
      })
      .eq('id', bugReport.id);

    if (bugUpdateError) {
      console.error('Error updating bug status:', bugUpdateError);
      // Don't throw here as the main task was successful
    }

    console.log('Successfully completed Loveable processing for task:', taskId);

  } catch (error) {
    console.error('Error in simulateLoveableProcessing:', error);
    
    // Update task with error status
    await supabaseClient
      .from('ai_tasks')
      .update({
        status: 'failed',
        error_message: error instanceof Error ? error.message : 'Unknown error',
        updated_at: new Date().toISOString()
      })
      .eq('id', taskId);
  }
}